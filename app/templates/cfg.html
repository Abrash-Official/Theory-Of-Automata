{% extends "base.html" %}
{% block title %}Context-Free Grammars (CFG){% endblock %}
{% block content %}
<div class="card mb-4">
    <div class="card-header bg-info" id="cfgHeader">
        <h3 class="card-title mb-0">Context-Free Grammars (CFG)</h3>
    </div>
    <div class="card-body">
        <h4 class="mb-3">What is a Context-Free Grammar (CFG)?</h4>
        <div class="alert alert-info mt-2 p-3 rounded">
            <pre>
A CFG is a 4-tuple G=(V,Σ,R,S), where:

V: Finite set of non-terminal symbols (e.g., S,A,B)

Σ: Finite set of terminal symbols (e.g., a,b)

R: Production rules of the form A→α, where A∈V and α∈(V∪Σ)∗ 

S: Start symbol (S∈V)
</pre>
        </div>
        <p><strong>Example:</strong></p>
        <pre><code>S → aSb∣ϵ
A → aA∣a
</code></pre>
        <p>This CFG generates the language L={aⁿbⁿ∣n≥0}.</p>

        <h4 class="mt-4">Key Concepts</h4>
        <h5 class="mt-4">1. Language Generated by a CFG</h5>
        <div class="alert alert-info mt-2 p-3 rounded">
            <p>For a CFG <code class="text-nowrap">G</code>, <code class="text-nowrap">L(G)={w∈Σ∗∣S⇒∗w}</code>.</p>
            <h6>Example:</h6>
            <pre><code>G: S→AB, A→a, B→b</code></pre>
            <pre><code>L(G)={ab}.</code></pre>
        </div>

        <h5 class="mt-4">2. Simplification of CFGs</h5>
        <div class="alert alert-info mt-2 p-3 rounded">
            <p>CFGs can be simplified by:</p>
            <h6>Removing Useless Symbols:</h6>
            <ul>
                <li>Non-generating symbols: Symbols that cannot derive terminal strings.</li>
                <li>Non-reachable symbols: Symbols not reachable from <code class="text-nowrap">S</code>.</li>
            </ul>
            <h6>Eliminating ε-Productions:</h6>
            <p>Remove rules like <code class="text-nowrap">A→ϵ</code> unless <code class="text-nowrap">ϵ∈L(G)</code>.</p>
            <h6>Removing Unit Productions:</h6>
            <p>Eliminate rules like <code class="text-nowrap">A→B</code>.</p>
            <h6>Example:</h6>
            <p>Original CFG:</p>
            <pre><code>S→A∣a, A→B, B→b</code></pre>
            <p>Simplified CFG:</p>
            <pre><code>S→a∣b, B→b</code></pre>
        </div>

        <h4 class="mt-4">Normal Forms</h4>
        <h5 class="mt-4">1. Chomsky Normal Form (CNF)</h5>
        <div class="alert alert-info mt-2 p-3 rounded">
            <p>A CFG is in CNF if all rules are:</p>
            <ul>
                <li><code class="text-nowrap">A→BC</code> (two non-terminals)</li>
                <li><code class="text-nowrap">A→a</code> (single terminal)</li>
                <li><code class="text-nowrap">S→ϵ</code> (if <code class="text-nowrap">ϵ∈L(G)</code>)</li>
            </ul>
            <h6>Conversion Steps:</h6>
            <ol>
                <li>Eliminate ε-productions and unit productions.</li>
                <li>Replace mixed terminals (e.g., <code class="text-nowrap">A→aB</code> becomes <code class="text-nowrap">A→XB, X→a</code>).</li>
                <li>Break long rules (e.g., <code class="text-nowrap">A→BCD</code> becomes <code class="text-nowrap">A→BE, E→CD</code>).</li>
            </ol>
            <h6>Example:</h6>
            <p>Original CFG:</p>
            <pre><code>S→aSb∣ϵ</code></pre>
            <p>CNF:</p>
            <pre><code>S→XB∣ϵ, X→a, B→SY, Y→b</code></pre>
        </div>

        <h5 class="mt-4">2. Greibach Normal Form (GNF)</h5>
        <div class="alert alert-info mt-2 p-3 rounded">
            <p>A CFG is in GNF if all rules are <code class="text-nowrap">A→aα</code>, where <code class="text-nowrap">a∈Σ</code> and <code class="text-nowrap">α∈V∗</code>.</p>
            <h6>Conversion Steps:</h6>
            <ol>
                <li>Convert to CNF.</li>
                <li>Eliminate left recursion.</li>
                <li>Ensure productions start with terminals.</li>
            </ol>
            <h6>Example:</h6>
            <p>Original CFG:</p>
            <pre><code>S→AB, A→a, B→b</code></pre>
            <p>GNF:</p>
            <pre><code>S→aB, A→a, B→b</code></pre>
        </div>

        <h4 class="mt-4">Closure Properties</h4>
        <p>CFLs are closed under:</p>
        <div class="alert alert-info mt-2 p-3 rounded">
            <div class="table-responsive">
                <table class="table table-bordered table-striped">
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>Example</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Union</td>
                            <td><code class="text-nowrap">L₁∪L₂={aⁿbⁿ}∪{cᵐdᵐ}</code></td>
                        </tr>
                        <tr>
                            <td>Concatenation</td>
                            <td><code class="text-nowrap">L₁L₂={aⁿbⁿcᵐdᵐ}</code></td>
                        </tr>
                        <tr>
                            <td>Kleene Star</td>
                            <td><code class="text-nowrap">L∗={(aⁿbⁿ)ᵏ∣k≥0}</code></td>
                        </tr>
                        <tr>
                            <td>Homomorphism</td>
                            <td><code class="text-nowrap">h(a)=0, h(b)=1⇒h(L)={0ⁿ1ⁿ}</code></td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <p>Not closed under intersection or complement.</p>
        </div>

        <h4 class="mt-4">Applications</h4>
        <ul>
            <li>Programming Languages: Syntax of languages like C/Python defined via CFGs.</li>
            <li>Natural Language Processing: Parsing sentence structures.</li>
            <li>Compiler Design: Syntax analysis (parsing) phase.</li>
        </ul>

        <h4 class="mt-4">Practice Examples</h4>
        <h5 class="mt-4">1. Simplify the CFG</h5>
        <div class="alert alert-info mt-2 p-3 rounded">
            <p>Original:</p>
            <pre><code>S→AB∣a, A→a, B→C, C→c</code></pre>
            <p>Simplified:</p>
            <pre><code>S→a, A→a, C→c</code></pre>
        </div>

        <h5 class="mt-4">2. Convert to CNF</h5>
        <div class="alert alert-info mt-2 p-3 rounded">
            <p>Original:</p>
            <pre><code>S→aAb∣ϵ, A→aA∣a</code></pre>
            <p>CNF:</p>
            <pre><code>S→XA′∣ϵ, A′→YB, X→a, Y→a, B→b</code></pre>
        </div>

        <h4 class="mt-4">Code Example: Basic CFG Parser</h4>
        <div class="alert alert-info mt-2 p-3 rounded">
            <label for="pythonCodeInputCFG" class="form-label">Enter Python Code:</label>
            <textarea class="form-control" id="pythonCodeInputCFG" rows="15">
# A very simple CFG parser for the language L = {a^n b^n | n >= 0}
# Grammar: S -> aSb | epsilon

def parse_anbn(s):
    n = 0
    # Check for 'a's
    while n < len(s) and s[n] == 'a':
        n += 1
    
    # Check for 'b's
    m = 0
    while n + m < len(s) and s[n + m] == 'b':
        m += 1
    
    # If the number of 'a's equals 'b's and no other characters
    return n == m and (n + m) == len(s)

# Test cases
print(f"ab: {parse_anbn('ab')}")
print(f"aabb: {parse_anbn('aabb')}")
print(f"a: {parse_anbn('a')}")
print(f"b: {parse_anbn('b')}")
print(f"aaab: {parse_anbn('aaab')}")
print(f"Empty string: {parse_anbn('')}")
print(f"aba: {parse_anbn('aba')}")
            </textarea>
            <button type="button" class="btn btn-primary mb-3" id="runPythonCodeBtnCFG">Run Code</button>
            <h6>Output:</h6>
            <pre class="alert alert-info mt-2 p-3 rounded"><code id="pythonCodeOutputCFG"></code></pre>
        </div>

        <h4 class="mt-4">MCQs</h4>
        <div id="mcq-container-cfg">
            <div class="mcq-progress text-end mb-2"></div>
            <ol class="mcq-list" style="list-style: none; padding-left: 0;">
                <li data-correct-answer="B" class="mcq-question-item">
                    <p class="mb-3">Which normal form requires rules of the form <code class="text-nowrap">A→BC</code>?</p>
                    <div class="list-group mb-3">
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="A">A. Greibach</button>
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="B">B. Chomsky</button>
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="C">C. Regular</button>
                    </div>
                    <button type="button" class="btn btn-primary submit-mcq-btn">Submit Answer</button>
                    <p class="feedback mt-2"></p>
                </li>
                <li data-correct-answer="C" class="mcq-question-item" style="display: none;">
                    <p class="mb-3">CFLs are closed under:</p>
                    <div class="list-group mb-3">
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="A">A. Intersection</button>
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="B">B. Complement</button>
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="C">C. Union</button>
                    </div>
                    <button type="button" class="btn btn-primary submit-mcq-btn">Submit Answer</button>
                    <p class="feedback mt-2"></p>
                </li>
                <li data-correct-answer="C" class="mcq-question-item" style="display: none;">
                    <p class="mb-3">The language <code class="text-nowrap">{aⁿbⁿcⁿ∣n≥0}</code> is:</p>
                    <div class="list-group mb-3">
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="A">A. Regular</button>
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="B">B. Context-free</button>
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="C">C. Not context-free</button>
                    </div>
                    <button type="button" class="btn btn-primary submit-mcq-btn">Submit Answer</button>
                    <p class="feedback mt-2"></p>
                </li>
                <li data-correct-answer="A" class="mcq-question-item" style="display: none;">
                    <p class="mb-3">A CFG in GNF has productions starting with:</p>
                    <div class="list-group mb-3">
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="A">A. Terminals</button>
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="B">B. Non-terminals</button>
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="C">C. ε</button>
                    </div>
                    <button type="button" class="btn btn-primary submit-mcq-btn">Submit Answer</button>
                    <p class="feedback mt-2"></p>
                </li>
            </ol>
        </div>

        <h4 class="mt-4">Summary</h4>
        <ul>
            <li>CFGs define languages through production rules and are fundamental in parsing.</li>
            <li>Simplification and conversion to CNF/GNF enable efficient parsing algorithms.</li>
            <li>Understanding closure properties helps analyze language class relationships.</li>
        </ul>

    </div>
</div>
{% endblock %}

{% block scripts %}
<style>
    #cfgHeader {
        background-color: transparent !important;
    }
</style>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize CodeMirror for Python code input in CFG page
        const pythonCodeEditorElementCFG = document.getElementById('pythonCodeInputCFG');
        if (pythonCodeEditorElementCFG && typeof CodeMirror !== 'undefined') {
            window.AutomataEdu.codeEditorInstanceCFG = CodeMirror.fromTextArea(pythonCodeEditorElementCFG, {
                mode: 'python',
                theme: 'dracula',
                lineNumbers: true,
                indentUnit: 4,
                tabSize: 4,
                lineWrapping: true,
                readOnly: false
            });
            document.getElementById('runPythonCodeBtnCFG').addEventListener('click', runPythonCodeCFG);
        }

        // Event listeners for MCQ questions
        const mcqContainerCFG = document.getElementById('mcq-container-cfg');
        if (mcqContainerCFG) {
            const questions = mcqContainerCFG.querySelectorAll('.mcq-question-item');
            let currentQuestionIndex = 0;

            function updateMcqDisplay() {
                questions.forEach((q, index) => {
                    q.style.display = (index === currentQuestionIndex) ? 'block' : 'none';
                });
                updateMcqProgress();
            }

            function updateMcqProgress() {
                const progressText = mcqContainerCFG.querySelector('.mcq-progress');
                if (progressText) {
                    progressText.textContent = `Question ${currentQuestionIndex + 1} of ${questions.length}`;
                }
            }

            function resetQuestion(questionItem) {
                const options = questionItem.querySelectorAll('.mcq-option');
                options.forEach(option => {
                    option.classList.remove('selected-option', 'correct', 'incorrect');
                    option.disabled = false;
                });
                const feedback = questionItem.querySelector('.feedback');
                if (feedback) {
                    feedback.textContent = '';
                    feedback.classList.remove('text-success', 'text-danger');
                }
                const submitBtn = questionItem.querySelector('.submit-mcq-btn');
                if (submitBtn) {
                    submitBtn.style.display = 'block';
                }
            }

            questions.forEach(resetQuestion);
            updateMcqDisplay();

            mcqContainerCFG.addEventListener('click', function(event) {
                const target = event.target;

                if (target.classList.contains('mcq-option')) {
                    const questionItem = target.closest('.mcq-question-item');
                    const options = questionItem.querySelectorAll('.mcq-option');
                    options.forEach(option => option.classList.remove('selected-option'));
                    target.classList.add('selected-option');
                } else if (target.classList.contains('submit-mcq-btn')) {
                    const questionItem = target.closest('.mcq-question-item');
                    const selectedOption = questionItem.querySelector('.mcq-option.selected-option');
                    const feedback = questionItem.querySelector('.feedback');
                    const submitBtn = questionItem.querySelector('.submit-mcq-btn');
                    const correctAnswer = questionItem.dataset.correctAnswer;

                    if (selectedOption) {
                        if (selectedOption.dataset.option === correctAnswer) {
                            feedback.textContent = 'Correct!';
                            feedback.classList.remove('text-danger');
                            feedback.classList.add('text-success');
                            selectedOption.classList.add('correct');
                        } else {
                            feedback.textContent = `Incorrect. The correct answer was ${correctAnswer}.`;
                            feedback.classList.remove('text-success');
                            feedback.classList.add('text-danger');
                            selectedOption.classList.add('incorrect');
                            // Highlight correct answer
                            questionItem.querySelector(`.mcq-option[data-option="${correctAnswer}"]`).classList.add('correct');
                        }
                        // Disable all options after submission
                        questionItem.querySelectorAll('.mcq-option').forEach(option => option.disabled = true);
                        submitBtn.style.display = 'none';

                        // Show next question or prompt to restart after a delay
                        setTimeout(() => {
                            currentQuestionIndex++;
                            if (currentQuestionIndex < questions.length) {
                                updateMcqDisplay();
                            } else {
                                alert('You have completed all MCQ questions!');
                                currentQuestionIndex = 0;
                                questions.forEach(resetQuestion);
                                updateMcqDisplay();
                            }
                        }, 2000); // 2-second delay

                    } else {
                        feedback.textContent = 'Please select an answer.';
                        feedback.classList.remove('text-success', 'text-danger');
                        feedback.classList.add('text-warning');
                    }
                }
            });
        }
    });

    async function runPythonCodeCFG() {
        const outputElement = document.getElementById('pythonCodeOutputCFG');
        const codeEditor = window.AutomataEdu.codeEditorInstanceCFG;
        const code = codeEditor.getValue();
        outputElement.textContent = 'Running code...';

        try {
            const response = await fetch('/run_python_code', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ code: code }),
            });
            const data = await response.json();
            if (data.output) {
                outputElement.textContent = data.output;
            } else if (data.error) {
                outputElement.textContent = `Error: ${data.error}`;
                console.error('Python code execution error:', data.error);
            } else {
                outputElement.textContent = 'An unexpected error occurred.';
                console.error('Unexpected response from server:', data);
            }
        } catch (error) {
            outputElement.textContent = `Request failed: ${error}`;
            console.error('Fetch error:', error);
        }
    }

</script>
{% endblock %} 