{% extends "base.html" %}
{% block title %}Decidability and Computability Theory{% endblock %}
{% block content %}
<div class="card mb-4">
    <div class="card-header" id="decidabilityHeader">
        <h3 class="card-title mb-0">Decidability and Computability Theory</h3>
    </div>
    <div class="card-body">
        <h4 class="mb-3">Introduction</h4>
        <div class="alert alert-info mt-2 p-3 rounded overflow-x-auto">
            <pre style="white-space: pre-wrap; word-break: break-word;">
Decidability determines whether a problem can be solved by an algorithm that always halts with a yes/no answer. Computability theory explores the limits of algorithmic computation, classifying problems as computable (solvable) or non-computable (unsolvable). These concepts form the foundation of theoretical computer science, defining what machines can and cannot do.
            </pre>
        </div>
        <h4 class="mt-4">Key Definitions</h4>
        <div class="alert alert-info mt-2 p-3 rounded overflow-x-auto">
            <ul>
                <li><b>Decidable Problem:</b> A problem is decidable if there exists a Turing Machine (TM) that halts on every input and returns "yes" or "no".<br><b>Example:</b> Checking if a number is prime.</li>
                <li><b>Undecidable Problem:</b> No TM can solve the problem for all inputs. The TM may loop infinitely on some inputs.<br><b>Example:</b> The Halting Problem (determining if a program will terminate).</li>
                <li><b>Computable Function:</b> A function is computable if a TM can compute its output for every input.<br><b>Example:</b> Integer addition.</li>
                <li><b>Partially Decidable (Semi-Decidable):</b> A TM halts on "yes" instances but may loop on "no" instances.<br><b>Example:</b> Membership in a recursively enumerable language.</li>
            </ul>
        </div>
        <h4 class="mt-4">Decidable vs. Undecidable Problems</h4>
        <div class="table-responsive bg-dark p-2 rounded">
            <table class="table table-bordered table-sm text-white">
                <thead class="table-light">
                    <tr><th>Aspect</th><th>Decidable Problems</th><th>Undecidable Problems</th></tr>
                </thead>
                <tbody>
                    <tr><td>Algorithm</td><td>Exists and always halts</td><td>No algorithm exists for all inputs</td></tr>
                    <tr><td>Examples</td><td>Primality testing, DFA equivalence</td><td>Halting Problem, CFG ambiguity</td></tr>
                    <tr><td>Practical Implication</td><td>Used in compilers, regex matching</td><td>Limits AI, program verification</td></tr>
                    <tr><td>Formal Language Class</td><td>Recursive (REC)</td><td>Recursively Enumerable (RE) but not REC</td></tr>
                </tbody>
            </table>
        </div>
        <h4 class="mt-4">The Halting Problem</h4>
        <div class="alert alert-info mt-2 p-3 rounded overflow-x-auto">
            <pre style="white-space: pre-wrap; word-break: break-word;">
The Halting Problem is the most famous undecidable problem. Given a program and input, no TM can determine if the program halts or runs forever.

Proof Sketch:
- Assume a TM H solves the Halting Problem.
- Construct a TM D that loops if H says D halts, and halts otherwise.
- Contradiction arises when D analyzes itself.
            </pre>
        </div>
        <h4 class="mt-4">Reducibility and Proving Undecidability</h4>
        <div class="alert alert-info mt-2 p-3 rounded overflow-x-auto">
            <pre style="white-space: pre-wrap; word-break: break-word;">
A problem A is reducible to B (A ≤ B) if solving B solves A. If A is undecidable, B is also undecidable.

Example:
Problem: Determine if a TM enters a specific state (State Entry Problem).
Reduction: Reduce the Halting Problem to this. If the state entry problem were decidable, the Halting Problem would be decidable—a contradiction.
            </pre>
        </div>
        <h4 class="mt-4">Rice's Theorem</h4>
        <div class="alert alert-info mt-2 p-3 rounded overflow-x-auto">
            <pre style="white-space: pre-wrap; word-break: break-word;">
Statement: Every non-trivial property of recursively enumerable languages is undecidable.
Non-trivial: The property is neither always true nor always false.
Example: Determining if a TM accepts an infinite language.
            </pre>
        </div>
        <h4 class="mt-4">Computable vs. Non-Computable Problems</h4>
        <div class="table-responsive bg-dark p-2 rounded">
            <table class="table table-bordered table-sm text-white">
                <thead class="table-light">
                    <tr><th></th><th>Computable</th><th>Non-Computable</th></tr>
                </thead>
                <tbody>
                    <tr><td>Definition</td><td>Solvable by an algorithm</td><td>Not solvable by any algorithm</td></tr>
                    <tr><td>Examples</td><td>GCD calculation, shortest path</td><td>Halting Problem, Post Correspondence Problem</td></tr>
                    <tr><td>Applications</td><td>Cryptography, data compression</td><td>Limits of AI, program verification</td></tr>
                </tbody>
            </table>
        </div>
        <h4 class="mt-4">Methods to Prove Undecidability</h4>
        <ul>
            <li><b>Direct Proof:</b> Use diagonalization (e.g., Halting Problem).</li>
            <li><b>Reduction:</b> Show problem A reduces to known undecidable problem B.</li>
            <li><b>Rice's Theorem:</b> Apply for properties of RE languages.</li>
        </ul>
        <h4 class="mt-4">MCQs on Decidability</h4>
        <div id="mcq-container-decidability">
            <div class="mcq-progress text-end mb-2"></div>
            <ol class="mcq-list" style="list-style: none; padding-left: 0;">
                <li data-correct-answer="B" class="mcq-question-item">
                    <p class="mb-3">Which is decidable?</p>
                    <div class="list-group mb-3">
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="A">A. CFG ambiguity</button>
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="B">B. DFA equivalence</button>
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="C">C. TM equivalence</button>
                    </div>
                    <button type="button" class="btn btn-primary submit-mcq-btn">Submit Answer</button>
                    <p class="feedback mt-2"></p>
                </li>
                <li data-correct-answer="B" class="mcq-question-item" style="display: none;">
                    <p class="mb-3">Rice's Theorem applies to:</p>
                    <div class="list-group mb-3">
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="A">A. Regular languages</button>
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="B">B. Non-trivial RE language properties</button>
                        <button type="button" class="list-group-item list-group-item-action mcq-option" data-option="C">C. Context-free grammars</button>
                    </div>
                    <button type="button" class="btn btn-primary submit-mcq-btn">Submit Answer</button>
                    <p class="feedback mt-2"></p>
                </li>
            </ol>
        </div>
        <h4 class="mt-4">Practical Implications</h4>
        <ul>
            <li><b>Compiler Design:</b> Decidable problems (e.g., syntax checking) enable efficient tools.</li>
            <li><b>Formal Verification:</b> Undecidability limits automated proof systems.</li>
            <li><b>Quantum Computing:</b> Extends but does not eliminate classical computability limits.</li>
        </ul>
        <h4 class="mt-4">Conclusion</h4>
        <div class="alert alert-info mt-2 p-3 rounded overflow-x-auto">
            <pre style="white-space: pre-wrap; word-break: break-word;">
Decidability and computability theory delineate the boundaries of computation. While decidable problems underpin practical computing, undecidable problems reveal inherent limitations, guiding research in algorithms, complexity, and artificial intelligence. Understanding these concepts is essential for tackling challenges in automata theory, programming languages, and beyond.
            </pre>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<style>
    #decidabilityHeader {
        background-color: transparent !important;
    }
    .overflow-x-auto {
        overflow-x: auto !important;
    }
</style>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // MCQ logic for Decidability page
        const mcqContainer = document.getElementById('mcq-container-decidability');
        if (mcqContainer) {
            const questions = mcqContainer.querySelectorAll('.mcq-question-item');
            let currentQuestionIndex = 0;
            function updateMcqDisplay() {
                questions.forEach((q, index) => {
                    q.style.display = (index === currentQuestionIndex) ? 'block' : 'none';
                });
                updateMcqProgress();
            }
            function updateMcqProgress() {
                const progressText = mcqContainer.querySelector('.mcq-progress');
                if (progressText) {
                    progressText.textContent = `Question ${currentQuestionIndex + 1} of ${questions.length}`;
                }
            }
            function resetQuestion(questionItem) {
                const options = questionItem.querySelectorAll('.mcq-option');
                options.forEach(option => {
                    option.classList.remove('selected-option', 'correct', 'incorrect');
                    option.disabled = false;
                });
                const feedback = questionItem.querySelector('.feedback');
                if (feedback) {
                    feedback.textContent = '';
                    feedback.classList.remove('text-success', 'text-danger');
                }
                const submitBtn = questionItem.querySelector('.submit-mcq-btn');
                if (submitBtn) {
                    submitBtn.style.display = 'block';
                }
            }
            questions.forEach(resetQuestion);
            updateMcqDisplay();
            mcqContainer.addEventListener('click', function(event) {
                const target = event.target;
                if (target.classList.contains('mcq-option')) {
                    const questionItem = target.closest('.mcq-question-item');
                    const options = questionItem.querySelectorAll('.mcq-option');
                    options.forEach(option => option.classList.remove('selected-option'));
                    target.classList.add('selected-option');
                } else if (target.classList.contains('submit-mcq-btn')) {
                    const questionItem = target.closest('.mcq-question-item');
                    const selectedOption = questionItem.querySelector('.mcq-option.selected-option');
                    const feedback = questionItem.querySelector('.feedback');
                    const submitBtn = questionItem.querySelector('.submit-mcq-btn');
                    const correctAnswer = questionItem.dataset.correctAnswer;
                    if (selectedOption) {
                        if (selectedOption.dataset.option === correctAnswer) {
                            feedback.textContent = 'Correct!';
                            feedback.classList.remove('text-danger');
                            feedback.classList.add('text-success');
                            selectedOption.classList.add('correct');
                        } else {
                            feedback.textContent = `Incorrect. The correct answer was ${correctAnswer}.`;
                            feedback.classList.remove('text-success');
                            feedback.classList.add('text-danger');
                            selectedOption.classList.add('incorrect');
                            questionItem.querySelector(`.mcq-option[data-option="${correctAnswer}"]`).classList.add('correct');
                        }
                        questionItem.querySelectorAll('.mcq-option').forEach(option => option.disabled = true);
                        submitBtn.style.display = 'none';
                        setTimeout(() => {
                            currentQuestionIndex++;
                            if (currentQuestionIndex < questions.length) {
                                updateMcqDisplay();
                            } else {
                                alert('You have completed all MCQ questions!');
                                currentQuestionIndex = 0;
                                questions.forEach(resetQuestion);
                                updateMcqDisplay();
                            }
                        }, 2000);
                    } else {
                        feedback.textContent = 'Please select an answer.';
                        feedback.classList.remove('text-success', 'text-danger');
                        feedback.classList.add('text-warning');
                    }
                }
            });
        }
    });
</script>
{% endblock %} 